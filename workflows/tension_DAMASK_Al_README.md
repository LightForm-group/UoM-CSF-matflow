# Notes on the `tension_DAMASK_Al` workflow

## Initial options

We will use the example uniaxial simulation profile file located [here on GitHuB](https://github.com/LightForm-group/UoM-CSF-matflow/blob/master/workflows/tension_DAMASK_Al.yml). Let's go through the different sections of the workflow file. First of all, we see this block:

```yaml
name: tension_DAMASK_Al
archive: dropbox
run_options:
  l: short
```

The `name` parameter is used when MatFlow generates a directory for the workflow; this directory will be the name, followed by a date and time stamp. Here, `stats` is set to `false`, meaning MatFlow will not run extra accounting jobs to record extra information like the memory usage, which is usually not needed, but might be useful when performing benchmarking. The `archive` key is set in this case to `dropbox`, which is the name of an archive location definition within my `~/.matflow/config.yml` file. Within the config file, the archive location is defined like this:

```yaml
archive_locations:
  dropbox:
    cloud_provider: dropbox
    path: /matflow/archived
```

In the above, the `path` key is defined relative to the root directory in my Dropbox account.

Finally, `run_options` specifies the default scheduler options that should be used by the tasks. Most of these options are passed directly to the scheduler, with the exception of `num_cores` and `alternate_scratch`.

## Tasks

Now let's look briefly at the tasks defined in this workflow. The first task is:

```yaml
  - name: generate_microstructure_seeds
    method: random
    software: damask
    base:
      grid_size: [4, 4, 4]
      num_grains: 3
    output_map_options:
      phase_label: Al
```

This task generates seed positions for the microstructure; these will become the grain centres. The initial RVE discretisation is specified here as well using the `grid_size` option. Notice also the use of the `output_map_options` key. This is used to specify any additional meta information that should be associated with the task output, but that does not actually modify the execution of the task itself. Here, we are using it to tell MatFlow that the generated microstructure seed positions should be associated with a phase labelled by `Al`.

The second task is to generate the model geometry that will be simulated by DAMASK:
    
```yaml
  - name: generate_volume_element
    method: random_voronoi
    software: damask
    base:
      size: [1, 1, 1]
      homog_label: SX
```

We specify that the volume element should be generated by using a random voronoi tessellation, in this case using the processing tools available in DAMASK.

The next task is simply to provide a visualisation of the volume element, in the form of a VTR file, which can be viewed directly within Paraview:
    
```yaml
  - name: visualise_volume_element
    method: VTK
    software: damask
```

After this, we need to generate a load case for the simulation, to tell DAMASK by how much to deform the volume element. This task is specified like this:

```yaml
  - name: generate_load_case
    method: uniaxial
    software: formable
    base:
      total_times: [100]
      num_increments: [200]
      target_strain_rates: [1.0e-3]
      directions: [x]
```

Here, we specify that the loading should be uniaxial in the model x-direction. We also specify for how long loading should continue, and over how many increments DAMASK should partition the load case. Notice that the loading keys specified here are lists, rather than single numbers. This is to support multiple sequential load cases within the same simulation. For instance, we could load first at a strain rate of 1e-3, and then at a strain rate of 1e-4. Alternatively, we might want to increase the number of increments per unit of strain in the elastic-plastic transition region, to make sure we sample the curvature sufficiently well.

Finally, we have the task to perform the actual simulation using DAMASK:

```yaml
 - name: simulate_volume_element_loading
    method: CP_FFT
    software: DAMASK
    run_options:
      num_cores: 4
      l: short
    output_map_options:
      operations:
        - name: add_Cauchy
          args: {P: P, F: F}
          opts: {add_Mises: true}
        - name: add_strain_tensor
          args: {F: F, t: V, m: 0}
          opts: {add_Mises: true}          
        - name: add_strain_tensor
          args: {F: Fp, t: V, m: 0}
          opts: {add_Mises: true}
      incremental_data:
        - name: vol_avg_equivalent_stress
          path: constituent/1_Al/generic/sigma_vM
          transforms: [mean_along_axes: 1]
        - name: vol_avg_equivalent_strain
          path: constituent/1_Al/generic/epsilon_V^0(F)_vM
          transforms: [mean_along_axes: 1]
        - name: vol_avg_equivalent_plastic_strain
          path: constituent/1_Al/generic/epsilon_V^0(Fp)_vM
          transforms: [mean_along_axes: 1]
          increments: 10 # E.g. extract data every 10th increment.
      visualise:
        increments: [0, -1] # Generate a VTK file for the initial and final increments
        labels: ['F', 'P', 'sigma_vM']           
    base:
      homogenization_schemes:
        SX:
          mech:
            type: none
      phases:
        Al:
          elasticity:
            type: hooke
            C_11: 106.75e9
            C_12: 60.41e9
            C_44: 28.34e9            
          generic:
            output: [F, P, Fp]
          lattice: fcc
          plasticity:
            N_sl: [12]
            a_sl: 2.25
            atol_xi: 1.0
            dot_gamma_0_sl: 0.001
            h_0_sl_sl: 75e6
            h_sl_sl: [1, 1, 1.4, 1.4, 1.4, 1.4]
            n_sl: 20
            output: [xi_sl]
            xi_0_sl: [31e6]
            xi_inf_sl: [63e6]
            type: phenopowerlaw
```

There are a few things to note here:
- We specify `run_options` here that differ from the default options we specified for all other tasks. This is because the simulation itself is, relatively, computationally expensive, and so requires more CPU cores to complete. Here we specify 4 cores.
- The `output_map_options` tell MatFlow which data from the DAMASK simulation should be saved into the workflow.
- There must be a phase listed in the `phases` key that matches the `phase_label` defined in the first task: `generate_microstructure_seeds`. There must also be a homogenization scheme listed in `homogenization_schemes` that matches the `homog_label` defined in the second task: `generate_volume_element`.

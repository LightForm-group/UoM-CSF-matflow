# Notes on the `tension_DAMASK_Al` workflow

## Initial options

We will use the example uniaxial simulation profile file located [here on GitHuB](https://github.com/LightForm-group/UoM-CSF-matflow/blob/master/workflows/tension_DAMASK_Al.yml). Let's go through the different sections of the workflow file. First of all, we see this block:

```yaml
name: tension_DAMASK_Al
archive: dropbox
run_options:
  l: short
```

The `name` parameter is used when MatFlow generates a directory for the workflow; this directory will be the name, followed by a date and time stamp. The `archive` key is set in this case to `dropbox`, which is the name of an archive location definition within my `~/.matflow/config.yml` file. Within the config file, the archive location is defined like this:

```yaml
archive_locations:
  dropbox:
    cloud_provider: dropbox
    path: /matflow/archived
```

In the above, the `path` key is defined relative to the root directory in my Dropbox account.

Finally, `run_options` specifies the default scheduler options that should be used by the tasks. Most of these options are passed directly to the scheduler, with the exception of `num_cores` and `alternate_scratch`.

## Tasks

Now let's look briefly at the tasks defined in this workflow. The first task is:

```yaml
  - name: generate_microstructure_seeds
    method: random
    software: damask
    base:
      size: [1, 1, 1]
      num_grains: 3
      phase_label: Al
```

This task generates seed positions for the microstructure; these will become the grain centres. The phase label is used to specify to which phase the seeds positions will belong, and is referenced later.

The second task is to generate the model geometry that will be simulated by DAMASK:
    
```yaml
  - name: generate_volume_element
    method: random_voronoi
    software: damask
    base:
      grid_size: [4, 4, 4]
      homog_label: SX
```

We specify that the volume element should be generated by using a random voronoi tessellation, in this case using the processing tools available in DAMASK. The RVE discretisation is specified here as well using the `grid_size` option.

The next task is simply to provide a visualisation of the volume element, in the form of a VTR file, which can be viewed directly within Paraview:
    
```yaml
  - name: visualise_volume_element
    method: VTK
    software: damask
```

After this, we need to generate a load case for the simulation, to tell DAMASK by how much to deform the volume element. This task is specified like this:

```yaml
  - name: generate_load_case
    method: uniaxial
    software: formable
    base:
      total_times: [100]
      num_increments: [200]
      target_strain_rates: [1.0e-3]
      directions: [x]
```

Here, we specify that the loading should be uniaxial in the model x-direction. We also specify for how long loading should continue, and over how many increments DAMASK should partition the load case. Notice that the loading keys specified here are lists, rather than single numbers. This is to support multiple sequential load cases within the same simulation. For instance, we could load first at a strain rate of 1e-3, and then at a strain rate of 1e-4. Alternatively, we might want to increase the number of increments per unit of strain in the elastic-plastic transition region, to make sure we sample the curvature sufficiently well.

Finally, we have the task to perform the actual simulation using DAMASK:

```yaml
  - name: simulate_volume_element_loading
    method: CP_FFT
    software: DAMASK
    run_options:
      num_cores: 4
      l: short
    output_map_options:
      operations:
        - name: add_stress_Cauchy
          args: { P: P, F: F }
          opts: { add_Mises: true }
        - name: add_strain
          args: { F: F, t: V, m: 0 }
          opts: { add_Mises: true }
        - name: add_strain
          args: { F: F_p, t: V, m: 0 }
          opts: { add_Mises: true }
        - name: add_IPF_color
          args: { l: [0, 0, 1] }
      phase_data:
        - field_name: sigma_vM
          phase_name: Al
          out_name: vol_avg_equivalent_stress
          transforms: [mean_along_axes: 1]
        - field_name: epsilon_V^0(F)_vM
          phase_name: Al
          out_name: vol_avg_equivalent_strain
          transforms: [mean_along_axes: 1]
        - field_name: epsilon_V^0(F_p)_vM
          phase_name: Al
          out_name: vol_avg_equivalent_plastic_strain
          transforms: [mean_along_axes: 1]
          increments:
            - step: 10
      field_data:
        # Extract the voxel orientations at initial and final increments
        - field_name: O
          increments:
            - values: [0, -1]
      grain_data:
        # Extract the grain-averaged orientations at initial and final increments
        - field_name: O
          increments:
            - values: [0, -1]
      visualise: # Generate VTR files for increments: [10, 12, 14, 16, 18, 20]
        fields: [F, F_p, P, sigma_vM, O, IPFcolor_(0 0 1)]
        increments:
          - start: 10
            stop: 20
            step: 2
    base:
      homogenization_schemes:
        SX:
          mechanical:
            type: pass
          N_constituents: 1
      phases:
        Al:
          lattice: cF
          mechanical:
            output: [F, P, F_p, O]
            elastic:
              type: Hooke
              C_11: 106.75e9
              C_12: 60.41e9
              C_44: 28.34e9
            plastic:
              type: phenopowerlaw
              output: [xi_sl]
              N_sl: [12]
              n_sl: 20
              a_sl: 2.25
              dot_gamma_0_sl: 0.001
              h_0_sl_sl: 573e6
              h_sl_sl: [1, 1, 1.4, 1.4, 1.4, 1.4]
              xi_0_sl: [22e6]
              xi_inf_sl: [129e6]
```

There are a few things to note here:
- We specify `run_options` here that differ from the default options we specified for all other tasks. This is because the simulation itself is, relatively, computationally expensive, and so requires more CPU cores to complete. Here we specify 4 cores.
- The `output_map_options` tell MatFlow which data from the DAMASK simulation should be saved into the workflow. This is split into a few things:
  - `operations` is a list of manipulations/processing to perform which modifies the DAMASK output file. For each list item, the `name` key corresponds to a DAMASK `Result` object method, which will be run using any specified `args` as keyword arguments.
  - `phase_data`, `field_data`, `grain_data`, and `volume_data` are used to extract out fields over a given domain (e.g. for a given phase, or for the whole RVE, or for grain-averaged quantities).
  - `visualise` provides an option to generate VTR files that can be visualised in ParaView. See [this document](DAMASK_visualise_examples.md) for some more example `visualise` blocks.
- There must be a phase listed in the `phases` key that matches the `phase_label` defined in the first task: `generate_microstructure_seeds`. There must also be a homogenization scheme listed in `homogenization_schemes` that matches the `homog_label` defined in the second task: `generate_volume_element`.
